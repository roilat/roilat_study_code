package cn.roilat.study.java.basic.operator;

/**
 * 对一些位运算符的测试
 * 
 * @author roilat-J
 * @version $Id: TestBitOperator.java, v 0.1 2019年4月11日 下午4:34:48 roilat-J Exp $
 */
public class TestBitOperator {

    public static void main(String[] args) {
        /**
         * 右边补0，即从11111111 11111111 11111111 11111111变成11111111 11111111 11111111 11111100（取反+1或者-1取反）=-4
         * 这里的放大是绝对值放大
         */
        System.out.println(-1 << 2);//-4
      /**
       * 直接加个-号，其实就是补码的负数转正数（取反+1或者-1取反）
       * Integer.MIN_VALUE=10000000 00000000 00000000 00000000
       * 01111111 11111111 11111111 11111111+1=10000000 00000000 00000000 00000000
       * 所以，计算结果不变
       */
        System.out.println(Math.abs(Integer.MIN_VALUE));//-2147483648
        
        /**
         * 无符号右移在多数情况下应该是不推荐使用的，或者说只对正数有效，负数直接坑爹了
         * 如例：11111111 11111111 11111111 11111111 >> 2= 00111111 11111111 11111111 11111111
         */
        System.out.println(-1 >>> 2);//1073741823
        
        /**
         * 有符号右移就科学多了（负数高位补1，正数高位补0），但是这个缩小的逻辑还是只是绝对值的缩小,且最小只能是-1，如果有涉及负数的右移要特别小心
         * 如例：11111111 11111111 11111111 11111111 >> 2= 11111111 11111111 11111111 11111111
         */
        System.out.println(-1 >> 2);//-1
        System.out.println(-4 >> 2);//-1
        System.out.println(-100 >> 2);//-25
        

    }

}
